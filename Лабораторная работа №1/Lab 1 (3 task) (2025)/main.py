# Программа для шифрования фамилии методом полибианского квадрата
# Используется русский алфавит

# Исходная фамилия
surname = "Колосов"

# Определяем русский алфавит
# Включает все буквы от 'А' до 'Я', включая 'Ё'
# Для формирования квадрата 6x6 (36 ячеек) нужно объединить 'И' и 'Й'
# или 'Е' и 'Ё'. Обычно 'Ё' помещают после 'Е'.
# В данном случае, для размера 6x6, объединим 'Е' и 'Ё'.
alphabet_for_square = "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"  # 33 буквы
# alphabet_for_square = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" # 33 буквы, 'Ё' отдельно

# Альтернативный алфавит, где 'Е' и 'Ё' объединены (заменяем 'Ё' на 'Е' в алфавите)
# или 'И' и 'Й' объединены. Выберем объединение 'И' и 'Й'.
# Для 6x6 нужно 36 символов. Объединим 'Е' и 'Ё', а также 'И' и 'Й'.
# Это даст нам 31 символ. Нужно добавить 5 фиктивных символов.
# Обычно добавляют цифры или символы.
# Стандартный подход для русского языка в квадрате 6x6 - объединить 'Е'/'Ё' и 'И'/'Й'.
# Для простоты будем использовать алфавит с 'Ё', но поместим его в квадрат 6x6,
# заменив 'Ё' на 'Е' при поиске индекса или наоборот, или просто исключив 'Ё' из алфавита.
# Или можно использовать квадрат 7x5 или 5x7, но стандартно для русского - 6x6.
# Попробуем 6x6, исключив 'Ё'. Тогда алфавит: АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ (32 буквы).
# Добавим 4 символа для 36. Обычно это цифры или специальные символы.
# Используем алфавит из 32 букв + 4 символа (например, 0123)
# Но в задании не сказано добавлять символы. Попробуем 6x6 с объединением.
# Объединим 'Е' и 'Ё'. Это означает, что 'Ё' будет иметь тот же код, что и 'Е'.
# Также объединим 'И' и 'Й'. 'Й' будет иметь тот же код, что и 'И'.
# Тогда наш "уникальный" алфавит для квадрата: АБВГДЕ(Ё)ЖЗИ(Й)КЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ (31 символ)
# Нужно 5 дополнительных. Возьмем, например, 01234 или просто пробелы/точки.
# Или просто сделаем 6x6 и в последнюю ячейку (36) положим 'Я'.
# Нет, лучше поступить как в классическом полибианском квадрате.
# Для русского языка 33 буквы. Стандартный квадрат 5x5 (25 ячеек) не подходит.
# Часто делают 6x6 (36 ячеек), объединяя похожие буквы или добавляя символы.
# Объединим 'Е' и 'Ё', 'И' и 'Й'.
# Алфавит для квадрата: АБВГД(Е/Ё)ЖЗ(И/Й)КЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ
# Это 31 символ. Заполняем 6x6 = 36 ячеек. Остается 5 ячеек.
# Заполним их, например, цифрами 0, 1, 2, 3, 4.
# Но в задании сказано "буквы заменяются на координаты".
# Возможно, ожидается квадрат 6x6 с буквами и, возможно, символами.
# Стандартный подход: использовать квадрат 6x6, исключив редкие буквы или объединив.
# В учебнике (стр. 30) показан пример с 33-мя буквами, но таблица 6x6 (36 ячеек).
# Там 'Ё' исключено или объединено. См. Таблица 3.3 – Шифрозамены для лозунгового шифра.
# Но в Таблице 3.3 - это лозунг, а не квадрат.
# См. также Таблица 3.7 – Ключевая таблица для шифра Playfair (стр. 36).
# Там квадрат 6x6 для русского языка с 'Ё' в отдельной ячейке, и дополнительными символами в конце.
# Для квадрата 6x6 (6 строк x 6 столбцов) нужно 36 ячеек.
# Русский алфавит: 33 буквы.
# Объединим 'Е' и 'Ё', 'И' и 'Й'. Получаем 31 символ.
# Добавим 5 фиктивных символов (например, 1, 2, 3, 4, 5) для заполнения.
# Или, как в примере с Playfair, добавим символы в конец.
# Пусть будет квадрат 6x6, заполненный русским алфавитом + 3 символа.
# alphabet_polybius = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ12" # 35
# alphabet_polybius = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ123" # 36
# Это один из вариантов. Или объединить буквы.
# Объединим 'Е' и 'Ё', 'И' и 'Й'. Тогда алфавит для квадрата:
# alphabet_polybius = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" + "ЕЁИЙ" # нет, так не пойдет
# Нужно 36 уникальных ячеек.
# alphabet_polybius = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ123" # Исключим 'Ё', 'Й' и добавим 3 символа.
# Нет, лучше объединить. 'Ё' будет кодироваться как 'Е', 'Й' как 'И'.
# alphabet_polybius = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ" # 31 буква
# Осталось 5 ячеек. alphabet_polybius += "01234" # Теперь 36.
# Но при шифровании 'Ё' -> 'Е', 'Й' -> 'И'.
# Это стандартный способ.
# Итак, формируем алфавит для квадрата 6x6.
# Основной алфавит: АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ (33)
# Объединяем 'Ё' с 'Е', 'Й' с 'И'. Получаем: АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ (31)
# Добавляем 5 символов: 01234 (или что-то еще). alphabet_polybius = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ01234"
# Но что делать с 'Ё' и 'Й' при шифровании?
# При шифровании: если буква 'Ё', ищем индекс 'Е'. Если 'Й', ищем индекс 'И'.
# Это требует специальной обработки.
# Лучше создать словарь соответствия: буква -> индекс в квадрате.
# Определим размер квадрата
square_size = 6  # 6x6 квадрат

# Создаем алфавит для квадрата, объединяя 'Ё' с 'Е' и 'Й' с 'И', и добавляя символы для заполнения
# Полный алфавит
full_alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"  # 33 буквы

# Создаем алфавит для квадрата 6x6 (36 символов)
# Исключаем 'Ё' и 'Й', добавляем 3 символа (например, цифры)
alphabet_for_square_6x6 = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ012"  # 31 + 3 = 34 символа
# Нужно 36. Добавим еще 2.
alphabet_for_square_6x6 = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ01234"  # 31 + 5 = 36 символов

# Создаем квадрат (список списков) размером square_size x square_size
polybius_square = []
for i in range(square_size):
    row = []
    for j in range(square_size):
        # Вычисляем индекс символа в строке alphabet_for_square_6x6
        index = i * square_size + j
        if index < len(alphabet_for_square_6x6):
            row.append(alphabet_for_square_6x6[index])
        else:
            # Если индекс выходит за пределы, добавляем пустую строку или фиктивный символ
            # В идеале, длина алфавита должна быть равна square_size * square_size
            row.append('')  # Это не должно произойти, если длина алфавита 36
    polybius_square.append(row)


# Функция для получения координат символа в квадрате
def get_coordinates(char, square, alphabet):
    """
    Находит координаты (строка, столбец) символа в полибианском квадрате.

    :param char: Символ для поиска (строка, длина 1).
    :param square: Полибианский квадрат (список списков).
    :param alphabet: Алфавит, использованный для заполнения квадрата (строка).
    :return: Кортеж (row, col) индексов (int, int) или (-1, -1), если символ не найден.
    """
    # Обработка объединения букв: 'Ё' -> 'Е', 'Й' -> 'И'
    processed_char = char
    if processed_char == 'Ё':
        processed_char = 'Е'
    elif processed_char == 'Й':
        processed_char = 'И'

    # Ищем символ в квадрате
    for r in range(len(square)):
        for c in range(len(square[r])):
            if square[r][c] == processed_char:
                return r, c
    # Если символ не найден, возвращаем (-1, -1)
    return -1, -1


# Функция для шифрования строки с помощью полибианского квадрата
def polybius_cipher(text, square):
    """
    Шифрует текст с помощью полибианского квадрата.

    :param text: Исходный текст для шифрования (строка).
    :param square: Полибианский квадрат (список списков).
    :return: Зашифрованный текст, состоящий из координат (строка).
    """
    # Преобразуем входной текст в верхний регистр
    text_upper = text.upper()

    # Инициализируем строку для хранения результата (координат)
    encrypted_coords = ""

    # Проходим по каждой букве в тексте
    for char in text_upper:
        # Получаем координаты символа в квадрате
        row, col = get_coordinates(char, square, alphabet_for_square_6x6)

        # Проверяем, был ли символ найден
        if row != -1 and col != -1:
            # Преобразуем индексы в номера строк/столбцов, начиная с 1 (обычно так принято)
            # Индексы в списке начинаются с 0, поэтому прибавляем 1
            coord_str = str(row + 1) + str(col + 1)
            # Добавляем координаты к результату
            encrypted_coords += coord_str
        else:
            # Если символ не найден в квадрате (например, пробел или знак препинания),
            # его можно пропустить или обработать особым образом.
            # В данном случае, мы просто пропускаем его, так как квадрат ограничен.
            # Если в задании требуют обработки, можно добавить else-ветку.
            # print(f"Символ '{char}' не найден в полибианском квадрате и будет пропущен.")
            pass  # Пропускаем символ, не добавляя ничего к результату

    # Возвращаем строку с координатами
    return encrypted_coords


# Вызываем функцию шифрования с нашими параметрами
encrypted_surname = polybius_cipher(surname, polybius_square)

# Выводим результаты
print(f"Исходное сообщение: {surname}")
print(f"Размер квадрата: {square_size}x{square_size}")
print("Содержимое полибианского квадрата:")
for row in polybius_square:
    print(row)
print(f"Алфавит (и символы) для заполнения квадрата: {alphabet_for_square_6x6}")
print(f"Зашифрованное сообщение (координаты): {encrypted_surname}")
