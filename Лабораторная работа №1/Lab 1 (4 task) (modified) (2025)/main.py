# Программа для шифрования фамилии методом шифра Трисемуса
# Используется русский алфавит

# Запрашиваем у пользователя фамилию
surname = input("Введите вашу фамилию: ").strip()

# Запрашиваем у пользователя ключевое слово для формирования таблицы Трисемуса
keyword = input("Введите ключевое слово для шифра Трисемуса: ").strip()

# Определяем русский алфавит
# Включает все буквы от 'А' до 'Я', включая 'Ё'
alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"


# Функция для создания таблицы Трисемуса
def create_trisemus_table(keyword, original_alphabet, rows=6, cols=6):
    """
    Создает таблицу для шифра Трисемуса.

    :param keyword: Ключевое слово (строка).
    :param original_alphabet: Оригинальный алфавит (строка).
    :param rows: Количество строк в таблице (int).
    :param cols: Количество столбцов в таблице (int).
    :return: Таблица Трисемуса (список списков).
    """
    # Приводим ключевое слово к верхнему регистру
    keyword_upper = keyword.upper()

    # Создаем список для хранения уникальных букв из ключа в порядке их появления
    unique_keyword_letters = []
    # Множество для быстрой проверки, была ли буква уже добавлена
    seen_letters = set()

    # Проходим по каждой букве в ключевом слове
    for char in keyword_upper:
        # Проверяем, является ли символ буквой из оригинального алфавита
        # и не встречалась ли она уже в ключе
        if char in original_alphabet and char not in seen_letters:
            # Добавляем букву в список уникальных букв ключа
            unique_keyword_letters.append(char)
            # Добавляем букву в множество просмотренных
            seen_letters.add(char)
        # Если символ не из алфавита или уже был добавлен, игнорируем его

    # Создаем алфавит для заполнения таблицы
    # Начинаем с уникальных букв из ключа
    table_alphabet = "".join(unique_keyword_letters)

    # Затем добавляем оставшиеся буквы из оригинального алфавита,
    # которые не вошли в ключ
    for char in original_alphabet:
        if char not in seen_letters:
            table_alphabet += char

    # Теперь заполняем таблицу размером rows x cols
    # Создаем пустую таблицу
    table = []
    for i in range(rows):
        row = []
        for j in range(cols):
            # Вычисляем индекс символа в строке table_alphabet
            index = i * cols + j

            # Проверяем, не вышли ли мы за пределы алфавита
            if index < len(table_alphabet):
                # Добавляем символ из алфавита в ячейку таблицы
                row.append(table_alphabet[index])
            else:
                # Если индекс выходит за пределы, добавляем пустую строку или фиктивный символ
                # В данном случае, для 33 букв + 3 символа = 36 (6x6), этого не должно произойти,
                # если размер таблицы позволяет вместить весь алфавит.
                # Если алфавит короче, можно добавить фиктивные символы или оставить пустым.
                # В примере из учебника (Таблица 3.4) используются фиктивные символы '-'.
                # В данном случае, добавим символ '-', если места в алфавите не хватает.
                row.append('-')
        # Добавляем заполненную строку в таблицу
        table.append(row)

    # Возвращаем готовую таблицу
    return table


# Функция для получения координат символа в таблице Трисемуса
def get_coordinates_trisemus(char, table):
    """
    Находит координаты (строка, столбец) символа в таблице Трисемуса.

    :param char: Символ для поиска (строка, длина 1).
    :param table: Таблица Трисемуса (список списков).
    :return: Кортеж (row, col) индексов (int, int) или (-1, -1), если символ не найден.
    """
    # Обработка объединения букв (если применимо, в классическом Трисемусе - нет объединения)
    # processed_char = char
    # Для русского алфавита в 6x6 таблице 'Ё' и 'Й' могут быть исключены или объединены.
    # В данном случае, будем искать символ как есть.
    # Если символа нет в таблице, его можно пропустить или обработать особым образом.
    # Обычно шифруются только буквы, находящиеся в таблице.

    # Ищем символ в таблице
    for r in range(len(table)):
        for c in range(len(table[r])):
            if table[r][c] == char:
                return r, c
    # Если символ не найден, возвращаем (-1, -1)
    return -1, -1


# Функция для шифрования строки с помощью шифра Трисемуса
def trisemus_cipher(text, keyword, original_alphabet, table_rows=6, table_cols=6):
    """
    Шифрует текст с помощью шифра Трисемуса.

    :param text: Исходный текст для шифрования (строка).
    :param keyword: Ключевое слово для формирования таблицы (строка).
    :param original_alphabet: Оригинальный алфавит (строка).
    :param table_rows: Количество строк в таблице (int).
    :param table_cols: Количество столбцов в таблице (int).
    :return: Зашифрованный текст (строка).
    """
    # Преобразуем входной текст в верхний регистр
    text_upper = text.upper()

    # Создаем таблицу Трисемуса
    trisemus_table = create_trisemus_table(keyword, original_alphabet, table_rows, table_cols)

    # Инициализируем строку для хранения результата
    encrypted_text = ""

    # Проходим по каждой букве в тексте
    for char in text_upper:
        # Получаем координаты символа в таблице
        row, col = get_coordinates_trisemus(char, trisemus_table)

        # Проверяем, был ли символ найден
        if row != -1 and col != -1:
            # В классическом шифре Трисемуса (стр. 42 учебника):
            # Первая буква шифруется, используя первую строку, вторая — вторую и так далее.
            # После того как используется последняя строка, процесс повторяется с первой.
            # Индекс текущего символа в исходном тексте (для определения строки шифрования)
            char_index_in_text = len(encrypted_text)  # Длина результата до добавления текущего символа

            # Вычисляем номер строки таблицы, которая используется для шифрования текущего символа
            # Нумерация строк в таблице начинается с 0, поэтому используем % len(table)
            encryption_row_index = char_index_in_text % len(trisemus_table)

            # Находим зашифрованный символ в этой строке (encryption_row_index) по столбцу (col)
            # original_row - это строка, где находится исходный символ
            # encryption_row - это строка, которую мы используем для выбора результата
            encrypted_char = trisemus_table[encryption_row_index][col]

            # Добавляем зашифрованный символ к результату
            encrypted_text += encrypted_char
        else:
            # Если символ не найден в таблице (например, пробел или знак препинания),
            # его можно пропустить или обработать особым образом.
            # В данном случае, мы просто пропускаем его, так как таблица ограничена.
            # print(f"Символ '{char}' не найден в таблице Трисемуса и будет пропущен.")
            pass  # Пропускаем символ, не добавляя ничего к результату

    # Возвращаем зашифрованный текст
    return encrypted_text


# Вызываем функцию шифрования с нашими параметрами
# Используем таблицу 6x6, так как русский алфавит (33) + 3 символа = 36
encrypted_surname = trisemus_cipher(surname, keyword, alphabet, 6, 6)

# Создаем таблицу для вывода
trisemus_table = create_trisemus_table(keyword, alphabet, 6, 6)

# Выводим результаты
print(f"Исходное сообщение: {surname}")
print(f"Ключ (лозунг): {keyword}")
print(f"Оригинальный алфавит: {alphabet}")
print("Таблица шифрозамен (таблица Трисемуса):")
for row in trisemus_table:
    print(row)
print(f"Зашифрованное сообщение: {encrypted_surname}")
