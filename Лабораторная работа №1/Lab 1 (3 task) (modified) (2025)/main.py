# Программа для шифрования фамилии методом полибианского квадрата
# Используется русский алфавит

# Запрашиваем у пользователя фамилию
surname = input("Введите вашу фамилию: ").strip()

# Определяем русский алфавит
alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"

# Фиксированный размер квадрата 6x6
square_size = 6

# Создаем алфавит для квадрата 6x6 (36 символов)
# Объединяем 'Ё' с 'Е', 'Й' с 'И', и добавляем 5 символов для заполнения
# Исключаем 'Ё' и 'Й', добавляем 5 символов (например, 0, 1, 2, 3, 4)
alphabet_for_square_6x6 = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ01234"  # 31 + 5 = 36 символов

# Создаем квадрат (список списков) размером square_size x square_size
polybius_square = []
for i in range(square_size):
    row = []
    for j in range(square_size):
        index = i * square_size + j
        if index < len(alphabet_for_square_6x6):
            row.append(alphabet_for_square_6x6[index])
        else:
            row.append('')  # Это не должно произойти, если длина алфавита 36
    polybius_square.append(row)


# Функция для получения координат символа в квадрате
def get_coordinates(char, square, alphabet):
    """
    Находит координаты (строка, столбец) символа в полибианском квадрате.

    :param char: Символ для поиска (строка, длина 1).
    :param square: Полибианский квадрат (список списков).
    :param alphabet: Алфавит, использованный для заполнения квадрата (строка).
    :return: Кортеж (row, col) индексов (int, int) или (-1, -1), если символ не найден.
    """
    # Обработка объединения букв: 'Ё' -> 'Е', 'Й' -> 'И'
    processed_char = char
    if processed_char == 'Ё':
        processed_char = 'Е'
    elif processed_char == 'Й':
        processed_char = 'И'

    # Ищем символ в квадрате
    for r in range(len(square)):
        for c in range(len(square[r])):
            if square[r][c] == processed_char:
                return r, c
    # Если символ не найден, возвращаем (-1, -1)
    return -1, -1


# Функция для шифрования строки с помощью полибианского квадрата
def polybius_cipher(text, square):
    """
    Шифрует текст с помощью полибианского квадрата.

    :param text: Исходный текст для шифрования (строка).
    :param square: Полибианский квадрат (список списков).
    :return: Зашифрованный текст, состоящий из координат (строка).
    """
    # Преобразуем входной текст в верхний регистр
    text_upper = text.upper()

    # Инициализируем строку для хранения результата (координат)
    encrypted_coords = ""

    # Проходим по каждой букве в тексте
    for char in text_upper:
        # Получаем координаты символа в квадрате
        row, col = get_coordinates(char, square, alphabet_for_square_6x6)

        # Проверяем, был ли символ найден
        if row != -1 and col != -1:
            # Преобразуем индексы в номера строк/столбцов, начиная с 1 (обычно так принято)
            # Индексы в списке начинаются с 0, поэтому прибавляем 1
            coord_str = str(row + 1) + str(col + 1)
            # Добавляем координаты к результату
            encrypted_coords += coord_str
        else:
            # Если символ не найден в квадрате (например, пробел или знак препинания),
            # его можно пропустить или обработать особым образом.
            # В данном случае, мы просто пропускаем его, так как квадрат ограничен.
            # print(f"Символ '{char}' не найден в полибианском квадрате и будет пропущен.")
            pass  # Пропускаем символ, не добавляя ничего к результату

    # Возвращаем строку с координатами
    return encrypted_coords


# Вызываем функцию шифрования с нашими параметрами
encrypted_surname = polybius_cipher(surname, polybius_square)

# Выводим результаты
print(f"Исходное сообщение: {surname}")
print(f"Размер квадрата: {square_size}x{square_size}")
print("Содержимое полибианского квадрата:")
for row in polybius_square:
    print(row)
print(f"Алфавит (и символы) для заполнения квадрата: {alphabet_for_square_6x6}")
print(f"Зашифрованное сообщение (координаты): {encrypted_surname}")
