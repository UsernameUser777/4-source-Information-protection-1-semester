import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import random

def grille_cipher_encrypt(text, size=4):
    """
    Шифрует текст с помощью шифра поворотной решетки (4x4).

    Этот метод шифрования работает следующим образом:
    1.  Создается специальная решетка (трафарет) размером size x size (в данном случае 4x4).
        В решетке вырезаются определенные ячейки. Количество вырезов обычно составляет
        1/4 от общего числа ячеек (для 4x4 это 4 выреза), чтобы при 4 поворотах
        решетки (0°, 90°, 180°, 270°) все ячейки таблицы были использованы ровно один раз.
    2.  Решетка накладывается на пустую таблицу того же размера.
    3.  Исходный текст вписывается в ячейки таблицы, соответствующие вырезам в решетке,
        в определенном порядке (например, слева направо, сверху вниз).
    4.  Затем решетка поворачивается (обычно на 90 градусов по часовой стрелке), и следующие
        символы текста вписываются в *новые* ячейки, которые теперь совпадают с вырезами.
    5.  Процедура повторяется еще дважды (итого 4 раза), пока не будут заполнены все ячейки
        таблицы (или текст не закончится, тогда заполняется пробелами).
    6.  Зашифрованный текст формируется путем считывания заполненной таблицы
        (например, по строкам).

    :param text: Исходный текст для шифрования (str).
                 Пример: "Колосов Станислав".
    :param size: Размер решетки (int), должен быть 4 для данной реализации.
                 Пример: 4.
    :return: tuple:
             - encrypted_text (str): Зашифрованный текст.
             - table (list of lists): Виртуальная таблица после заполнения через решетку.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер решетки фиксирован на 4x4.")

    # Дополняем текст пробелами до длины 16 (размер таблицы 4x4)
    padded_text = text.ljust(size * size)

    # --- Определяем позиции вырезов в начальной ориентации решетки ---
    # Ключом является сама решетка, т.е. набор позиций вырезов.
    # Жестко задаем пример решетки, удовлетворяющей условию уникального покрытия.
    # Позиции вырезов в исходной ориентации (индексы строк и столбцов от 0 до 3)
    # Например, [(0, 0), (0, 2), (1, 1), (2, 0)] - это просто пример.
    # Для корректной решетки, при 4 поворотах на 90 градусов,
    # все 16 ячеек (0,0) .. (3,3) должны быть покрыты ровно один раз.
    # Проверим это вручную для выбранного примера:
    # Поворот на 90: (r, c) -> (c, size-1-r)
    # Поворот на 180: (r, c) -> (size-1-r, size-1-c)
    # Поворот на 270: (r, c) -> (size-1-c, r)
    initial_holes = [(0, 0), (0, 2), (1, 1), (2, 0)] # Выбранный набор вырезов

    # Проверка уникальности покрытия (вручную для 4x4)
    all_positions_covered = set()
    current_holes = initial_holes[:]
    for rotation in range(4): # 4 позиции решетки (0°, 90°, 180°, 270°)
        for r_h, c_h in current_holes:
            all_positions_covered.add((r_h, c_h))
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        new_holes = []
        for r_h, c_h in current_holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        current_holes = new_holes
    # Если общее количество уникальных позиций не равно размеру таблицы, решетка некорректна
    if len(all_positions_covered) != size * size:
        raise ValueError("Выбранная решетка не покрывает все ячейки при 4 поворотах.")

    # Создаем пустую виртуальную таблицу (список списков), заполненную пустыми строками
    table = [['' for _ in range(size)] for _ in range(size)]

    # --- Заполняем таблицу через решетку ---
    # Проходим 4 раза, соответствующие 4 позициям решетки
    text_index = 0 # Индекс текущего символа в дополненном тексте
    holes = initial_holes[:] # Начинаем с исходного набора вырезов
    for rotation in range(4): # 4 позиции решетки
        # Проходим по текущим позициям вырезов и заполняем таблицу
        for r_h, c_h in holes:
            # Проверяем, не закончился ли текст (хотя он должен быть дополнен)
            if text_index < len(padded_text):
                table[r_h][c_h] = padded_text[text_index]
                text_index += 1
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        # для следующей итерации цикла
        new_holes = []
        for r_h, c_h in holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        holes = new_holes # Обновляем список вырезов для следующего "наложения" решетки

    # --- Считываем зашифрованный текст из заполненной таблицы ---
    # Обычно считывается по строкам, но может быть и по столбцам.
    encrypted_chars = []
    for r in range(size): # Проходим по строкам
        for c in range(size): # Проходим по столбцам в строке
            encrypted_chars.append(table[r][c]) # Добавляем символ

    # Возвращаем зашифрованный текст в виде строки и таблицу после заполнения
    return ''.join(encrypted_chars), table

def grille_cipher_decrypt(ciphertext, size=4):
    """
    Дешифрует текст, зашифрованный шифром поворотной решетки (4x4).

    Процесс дешифрования обратен шифрованию:
    1.  Создается пустая виртуальная таблица размером size x size.
    2.  Зашифрованный текст записывается в таблицу в фиксированном порядке
        (например, по строкам, как при считывании при шифровании).
    3.  Затем, используя ту же самую решетку (с теми же позициями вырезов)
        и ту же последовательность поворотов (0°, 90°, 180°, 270°),
        символы из таблицы извлекаются в порядке, соответствующем поворотам.
        То есть, сначала считываются символы из позиций, соответствующих
        вырезам в решетке при 0° повороте, затем при 90°, и т.д.

    :param ciphertext: Зашифрованный текст (str).
    :param size: Размер решетки (int), должен быть 4 для данной реализации.
    :return: str: Восстановленный (дешифрованный) текст.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер решетки фиксирован на 4x4.")

    # Проверяем, совпадает ли длина зашифрованного текста с размером таблицы
    if len(ciphertext) != size * size:
        raise ValueError("Длина зашифрованного текста не соответствует размеру таблицы.")

    # --- Используем ту же решетку, что и при шифровании ---
    initial_holes = [(0, 0), (0, 2), (1, 1), (2, 0)]

    # Заполняем таблицу из зашифрованного текста (по строкам)
    table = [['' for _ in range(size)] for _ in range(size)]
    text_index = 0
    for r in range(size):
        for c in range(size):
            table[r][c] = ciphertext[text_index]
            text_index += 1

    # --- Извлекаем символы из таблицы по порядку, определяемому решеткой и поворотами ---
    decrypted_chars = []
    holes = initial_holes[:]
    for rotation in range(4): # 4 позиции решетки
        # Проходим по текущим позициям вырезов и извлекаем символы из таблицы
        for r_h, c_h in holes:
            decrypted_chars.append(table[r_h][c_h])
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        new_holes = []
        for r_h, c_h in holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        holes = new_holes

    # Восстановленный текст (включая добавленные пробелы)
    decrypted_text_with_padding = ''.join(decrypted_chars)
    # Удаляем пробелы в конце, которые были добавлены при шифровании
    return decrypted_text_with_padding.rstrip(' ')

def generate_random_grille_holes(size=4):
    """
    Генерирует случайную корректную решетку Жана Древо (Grille de Fleissner) для заданного размера.
    Реализация для 4x4 упрощена, так как стандартные решетки часто фиксированы.
    Этот метод возвращает один из предопределенных вариантов для 4x4.
    """
    if size != 4:
        raise ValueError("Генерация решетки реализована только для размера 4x4.")

    # Список возможных корректных наборов вырезов для 4x4 решетки Жана Древо
    # Каждый набор - это 4 позиции (r, c), которые при 4 поворотах покрывают все 16 ячеек без повторений.
    possible_grilles = [
        [(0, 0), (0, 2), (1, 1), (2, 0)], # Пример 1
        [(0, 0), (0, 3), (1, 1), (2, 2)], # Пример 2
        [(0, 1), (0, 3), (1, 0), (2, 2)], # Пример 3
        [(0, 1), (1, 0), (2, 3), (3, 2)], # Пример 4
        # Можно добавить другие корректные наборы
    ]
    # Выбираем случайный набор
    return random.choice(possible_grilles)

def encrypt_action():
    """
    Обработчик кнопки 'Зашифровать' для интерфейса tkinter.

    Функция извлекает текст из поля ввода, вызывает функцию шифрования
    (размер решетки фиксирован), и выводит результат (исходный текст,
    размер решетки, позиции вырезов, повороты, таблицу, зашифрованный текст)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем текст из поля ввода фамилии и имени
    text = input_text.get()

    # Проверяем, введен ли текст
    if not text:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите фамилию и имя для шифрования.\n")
        return # Выходим из функции

    try:
        # Вызываем функцию шифрования с фиксированным размером 4
        encrypted_text, table = grille_cipher_encrypt(text, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр поворотной решетки (4x4) (Шифрование) ---\n")
        # Вставляем исходное сообщение
        output_text.insert(tk.END, f"Исходное сообщение: {text}\n")
        # Вставляем размер решетки
        output_text.insert(tk.END, f"Размер решетки: 4x4\n")
        # Вставляем позиции вырезов в начальной решетке (для визуализации ключа)
        output_text.insert(tk.END, f"Позиции вырезов в начальной решетке (0-based): [(0, 0), (0, 2), (1, 1), (2, 0)]\n")
        # Вставляем информацию о поворотах
        output_text.insert(tk.END, f"Повороты решетки: 0°, 90°, 180°, 270°\n")
        # Вставляем таблицу после заполнения через решетку
        output_text.insert(tk.END, f"Таблица (после заполнения через решетку): {table}\n")
        # Вставляем зашифрованное сообщение (по строкам)
        output_text.insert(tk.END, f"Зашифрованное сообщение (по строкам): {encrypted_text}\n\n")
    except Exception as e: # Ловим любые другие ошибки (например, некорректная решетка)
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")

def decrypt_action():
    """
    Обработчик кнопки 'Дешифровать' для интерфейса tkinter.

    Функция извлекает зашифрованный текст из поля ввода, вызывает функцию дешифрования
    (размер решетки фиксирован), и выводит результат (зашифрованный текст,
    размер решетки, позиции вырезов, восстановленное сообщение)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем зашифрованный текст из поля ввода
    ciphertext = input_text.get()

    # Проверяем, введен ли зашифрованный текст
    if not ciphertext:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите зашифрованное сообщение для дешифрования.\n")
        return # Выходим из функции

    try:
        # Вызываем функцию дешифрования с фиксированным размером 4
        decrypted_text = grille_cipher_decrypt(ciphertext, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр поворотной решетки (4x4) (Дешифрование) ---\n")
        # Вставляем зашифрованное сообщение
        output_text.insert(tk.END, f"Зашифрованное сообщение: {ciphertext}\n")
        # Вставляем размер решетки
        output_text.insert(tk.END, f"Размер решетки: 4x4\n")
        # Вставляем позиции вырезов в начальной решетке (для визуализации ключа)
        output_text.insert(tk.END, f"Позиции вырезов в начальной решетке (ключ): [(0, 0), (0, 2), (1, 1), (2, 0)]\n")
        # Вставляем восстановленное сообщение
        output_text.insert(tk.END, f"Восстановленное сообщение: {decrypted_text}\n\n")
    except Exception as e: # Ловим любые другие ошибки
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")

def generate_key_action():
    """
    Обработчик кнопки 'Сгенерировать решетку'.
    Генерирует случайный набор вырезов для решетки.
    """
    generated_holes = generate_random_grille_holes(size=4)
    # Отображаем сгенерированные вырезы в поле вывода, так как их сложно ввести вручную
    output_text.delete(1.0, tk.END)
    output_text.insert(tk.END, f"--- Сгенерированная решетка (4x4) ---\n")
    output_text.insert(tk.END, f"Позиции вырезов в начальной решетке (0-based): {generated_holes}\n")
    output_text.insert(tk.END, f"Повороты решетки: 0°, 90°, 180°, 270°\n")
    output_text.insert(tk.END, f"Ключ для использования в программе: [(0, 0), (0, 2), (1, 1), (2, 0)] (используется фиксированный ключ для шифрования/дешифрования)\n\n")


# --- Создание графического интерфейса ---
# Создаем главное окно приложения
root = tk.Tk()
# Устанавливаем заголовок окна
root.title("Шифр поворотной решетки (4x4) (Модифицированный)")
# Устанавливаем начальный размер окна
root.geometry("900x700")

# --- Виджеты ---

# Фрейм для ввода текста
input_frame = ttk.Frame(root)
input_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew", columnspan=2)
root.grid_columnconfigure(0, weight=1) # Делаем колонку 0 растягиваемой

# Метка для поля ввода фамилии и имени
input_label = ttk.Label(input_frame, text="Введите текст (фамилию и имя для остальных шифров):")
input_label.grid(row=0, column=0, sticky="w")

# Поле ввода для фамилии и имени
input_text = ttk.Entry(input_frame, width=60)
input_text.grid(row=1, column=0, sticky="ew", padx=(0, 10))
input_frame.grid_columnconfigure(0, weight=1) # Делаем колонку 0 внутри фрейма растягиваемой
input_text.insert(0, "Колосов Станислав")

# Кнопка генерации решетки
generate_key_button = ttk.Button(root, text="Сгенерировать решетку", command=generate_key_action)
generate_key_button.grid(row=1, column=0, padx=10, pady=5, sticky="w")

# Кнопки для шифрования и дешифрования
button_frame = ttk.Frame(root)
button_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew", columnspan=2)

encrypt_button = ttk.Button(button_frame, text="Зашифровать", command=encrypt_action)
encrypt_button.grid(row=0, column=0, padx=(0, 5))

decrypt_button = ttk.Button(button_frame, text="Дешифровать", command=decrypt_action)
decrypt_button.grid(row=0, column=1, padx=(5, 0))

# Метка для поля вывода результата
output_label = ttk.Label(root, text="Результат:")
output_label.grid(row=3, column=0, padx=10, pady=5, sticky="w")

# Текстовое поле с прокруткой для вывода результата
output_text = scrolledtext.ScrolledText(root, width=100, height=35)
output_text.grid(row=4, column=0, padx=10, pady=5, sticky="nsew", columnspan=2)

# --- Настройка сетки ---
# Делаем так, чтобы строка 4 (где поле вывода) растягивалась при изменении размера окна
root.grid_rowconfigure(4, weight=1)

# Запуск главного цикла обработки событий tkinter
root.mainloop()
