import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import random


def magic_square_encrypt(text, size=4):
    """
    Шифрует текст с помощью шифра магического квадрата 4x4.

    Этот метод шифрования работает следующим образом:
    1.  Используется заранее определенный магический квадрат заданного размера (в данном случае 4x4).
        Магический квадрат - это таблица, заполненная числами таким образом, что сумма чисел
        в каждой строке, каждом столбце и на обеих диагоналях одинакова.
        Пример стандартного магического квадрата 4x4 (сумма = 34):
        16  3  2 13
         5 10 11  8
         9  6  7 12
         4 15 14  1
    2.  Исходный текст разбивается на символы. Если текст короче размера таблицы (size*size),
        он дополняется пробелами.
    3.  Символы текста записываются в виртуальную таблицу (той же размерности), но не по порядку.
        Позиции для записи определяются *по возрастанию значений* в магическом квадрате.
        То есть, сначала записывается символ в позицию, соответствующую самому большому числу в
        магическом квадрате (в примере выше это 16 в позиции (0,0)), затем в позицию,
        соответствующую следующему по величине числу (15 в позиции (3,1)), и так далее,
        до самого маленького числа (1 в позиции (3,3)).
    4.  Зашифрованный текст формируется путем считывания заполненной таблицы
        в каком-либо фиксированном порядке, например, по строкам сверху вниз.

    :param text: Исходный текст для шифрования (str).
                 Пример: "Колосов Станислав".
    :param size: Размер квадрата (int), должен быть 4 для данной реализации.
                 Пример: 4.
    :return: tuple:
             - encrypted_text (str): Зашифрованный текст.
             - table (list of lists): Виртуальная таблица после заполнения по правилу
                                      магического квадрата.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер квадрата фиксирован на 4x4.")

    # Магический квадрат 4x4 (сумма строк, столбцов, диагоналей = 34)
    # Нумерация ячеек (строка, столбец) от 0 до 3:
    # Значения: 16  3  2 13
    #           5 10 11  8
    #           9  6  7 12
    #           4 15 14  1
    # Соответствующие индексы (0-базированные):
    # (0,0) (0,1) (0,2) (0,3)
    # (1,0) (1,1) (1,2) (1,3)
    # (2,0) (2,1) (2,2) (2,3)
    # (3,0) (3,1) (3,2) (3,3)
    # Чтобы заполнить таблицу, нужно пройти по индексам в порядке, соответствующем
    # убыванию значений в магическом квадрате (от 16 к 1).
    # Отсортированные индексы по убыванию значения в магическом квадрате:
    # 16 -> (0, 0), 15 -> (3, 1), 14 -> (3, 2), 13 -> (0, 3),
    # 12 -> (2, 3), 11 -> (1, 2), 10 -> (1, 1), 9 -> (2, 0),
    # 8 -> (1, 3), 7 -> (2, 2), 6 -> (2, 1), 5 -> (1, 0),
    # 4 -> (3, 0), 3 -> (0, 1), 2 -> (0, 2), 1 -> (3, 3)
    # Итоговый список индексов для заполнения:
    magic_square_indices = [
        (0, 0),  # 16
        (3, 1),  # 15
        (3, 2),  # 14
        (0, 3),  # 13
        (2, 3),  # 12
        (1, 2),  # 11
        (1, 1),  # 10
        (2, 0),  # 9
        (1, 3),  # 8
        (2, 2),  # 7
        (2, 1),  # 6
        (1, 0),  # 5
        (3, 0),  # 4
        (0, 1),  # 3
        (0, 2),  # 2
        (3, 3)  # 1
    ]

    # Дополняем текст пробелами до длины 16 (размер таблицы 4x4)
    padded_text = text.ljust(size * size)

    # Создаем пустую виртуальную таблицу (список списков), заполненную пустыми строками
    table = [['' for _ in range(size)] for _ in range(size)]

    # Заполняем таблицу по индексам, соответствующим убывающим значениям магического квадрата.
    # Проходим по индексам из списка и индексам символов в дополненном тексте.
    for i, (r, c) in enumerate(magic_square_indices):
        # Проверяем, не закончился ли текст (хотя он должен быть дополнен)
        if i < len(padded_text):
            table[r][c] = padded_text[i]

    # Формируем зашифрованный текст, считывая заполненную таблицу по строкам.
    encrypted_chars = []
    for r in range(size):  # Проходим по строкам
        for c in range(size):  # Проходим по столбцам в строке
            encrypted_chars.append(table[r][c])  # Добавляем символ

    # Возвращаем зашифрованный текст в виде строки и таблицу после заполнения
    return ''.join(encrypted_chars), table


def magic_square_decrypt(ciphertext, size=4):
    """
    Дешифрует текст, зашифрованный шифром магического квадрата 4x4.

    Процесс дешифрования обратен шифрованию:
    1.  Проверяется длина зашифрованного текста.
    2.  Создается пустая виртуальная таблица размером size x size.
    3.  Зашифрованный текст записывается в таблицу в фиксированном порядке
        (например, по строкам, как при считывании при шифровании).
    4.  Затем, используя ту же последовательность позиций, что и при шифровании
        (от самой большой ячейки к самой маленькой в магическом квадрате),
        символы из таблицы извлекаются и формируют исходное сообщение.

    :param ciphertext: Зашифрованный текст (str).
    :param size: Размер квадрата (int), должен быть 4 для данной реализации.
    :return: str: Восстановленный (дешифрованный) текст.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер квадрата фиксирован на 4x4.")

    # Проверяем, совпадает ли длина зашифрованного текста с размером таблицы
    if len(ciphertext) != size * size:
        raise ValueError("Длина зашифрованного текста не соответствует размеру таблицы.")

    # --- Используем ту же последовательность индексов, что и при шифровании ---
    magic_square_indices = [
        (0, 0),  # 16
        (3, 1),  # 15
        (3, 2),  # 14
        (0, 3),  # 13
        (2, 3),  # 12
        (1, 2),  # 11
        (1, 1),  # 10
        (2, 0),  # 9
        (1, 3),  # 8
        (2, 2),  # 7
        (2, 1),  # 6
        (1, 0),  # 5
        (3, 0),  # 4
        (0, 1),  # 3
        (0, 2),  # 2
        (3, 3)  # 1
    ]

    # Заполняем таблицу из зашифрованного текста (по строкам)
    table = [['' for _ in range(size)] for _ in range(size)]
    text_index = 0
    for r in range(size):
        for c in range(size):
            table[r][c] = ciphertext[text_index]
            text_index += 1

    # --- Извлекаем символы из таблицы в порядке, определяемом магическим квадратом ---
    # Проходим по индексам в том же порядке, что и при шифровании
    # и собираем символы из таблицы в том порядке, в котором они были туда помещены.
    decrypted_chars = []
    for r, c in magic_square_indices:
        decrypted_chars.append(table[r][c])

    # Восстановленный текст (включая добавленные пробелы)
    decrypted_text_with_padding = ''.join(decrypted_chars)
    # Удаляем пробелы в конце, которые были добавлены при шифровании
    return decrypted_text_with_padding.rstrip(' ')


def generate_random_magic_square(size=4):
    """
    Генерирует случайный магический квадрат 4x4.
    В рамках этого задания, магический квадрат фиксирован.
    Эта функция возвращает предопределенный квадрат и его индексы.
    """
    if size != 4:
        raise ValueError("Генерация магического квадрата реализована только для размера 4x4.")

    # Стандартный магический квадрат 4x4 (сумма 34)
    # [[16, 3, 2, 13],
    #  [5, 10, 11, 8],
    #  [9, 6, 7, 12],
    #  [4, 15, 14, 1]]

    # Индексы, отсортированные по убыванию значения (используются для заполнения при шифровании)
    indices = [
        (0, 0),  # 16
        (3, 1),  # 15
        (3, 2),  # 14
        (0, 3),  # 13
        (2, 3),  # 12
        (1, 2),  # 11
        (1, 1),  # 10
        (2, 0),  # 9
        (1, 3),  # 8
        (2, 2),  # 7
        (2, 1),  # 6
        (1, 0),  # 5
        (3, 0),  # 4
        (0, 1),  # 3
        (0, 2),  # 2
        (3, 3)  # 1
    ]
    # Отображаем пользователю, что используется стандартный квадрат
    return indices


def encrypt_action():
    """
    Обработчик кнопки 'Зашифровать' для интерфейса tkinter.

    Функция извлекает текст из поля ввода, вызывает функцию шифрования
    (размер квадрата фиксирован), и выводит результат (исходный текст,
    размер квадрата, пример магического квадрата, таблицу, зашифрованный текст)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем текст из поля ввода фамилии и имени
    text = input_text.get()

    # Проверяем, введен ли текст
    if not text:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите фамилию и имя для шифрования.\n")
        return  # Выходим из функции

    try:
        # Вызываем функцию шифрования с фиксированным размером 4
        encrypted_text, table = magic_square_encrypt(text, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр магического квадрата (4x4) (Шифрование) ---\n")
        # Вставляем исходное сообщение
        output_text.insert(tk.END, f"Исходное сообщение: {text}\n")
        # Вставляем размер квадрата
        output_text.insert(tk.END, f"Размер квадрата: 4x4\n")
        # Вставляем пример магического квадрата (для визуализации ключа/алгоритма)
        output_text.insert(tk.END, f"Магический квадрат (для порядка заполнения):\n")
        output_text.insert(tk.END, f" 16  3  2 13\n")
        output_text.insert(tk.END, f"  5 10 11  8\n")
        output_text.insert(tk.END, f"  9  6  7 12\n")
        output_text.insert(tk.END, f"  4 15 14  1\n")
        # Вставляем таблицу после заполнения по магическому квадрату
        output_text.insert(tk.END, f"Таблица (после заполнения по магическому квадрату): {table}\n")
        # Вставляем зашифрованное сообщение (по строкам)
        output_text.insert(tk.END, f"Зашифрованное сообщение (по строкам): {encrypted_text}\n\n")
    except Exception as e:  # Ловим любые другие ошибки
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")


def decrypt_action():
    """
    Обработчик кнопки 'Дешифровать' для интерфейса tkinter.

    Функция извлекает зашифрованный текст из поля ввода, вызывает функцию дешифрования
    (размер квадрата фиксирован), и выводит результат (зашифрованный текст,
    размер квадрата, восстановленное сообщение)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем зашифрованный текст из поля ввода
    ciphertext = input_text.get()

    # Проверяем, введен ли зашифрованный текст
    if not ciphertext:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите зашифрованное сообщение для дешифрования.\n")
        return  # Выходим из функции

    try:
        # Вызываем функцию дешифрования с фиксированным размером 4
        decrypted_text = magic_square_decrypt(ciphertext, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр магического квадрата (4x4) (Дешифрование) ---\n")
        # Вставляем зашифрованное сообщение
        output_text.insert(tk.END, f"Зашифрованное сообщение: {ciphertext}\n")
        # Вставляем размер квадрата
        output_text.insert(tk.END, f"Размер квадрата: 4x4\n")
        # Вставляем восстановленное сообщение
        output_text.insert(tk.END, f"Восстановленное сообщение: {decrypted_text}\n\n")
    except Exception as e:  # Ловим любые другие ошибки
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")


def generate_key_action():
    """
    Обработчик кнопки 'Сгенерировать квадрат'.
    Отображает информацию о стандартном магическом квадрате.
    """
    # Генерируем (или просто получаем) стандартный квадрат
    indices = generate_random_magic_square(size=4)
    # Отображаем информацию в поле вывода
    output_text.delete(1.0, tk.END)
    output_text.insert(tk.END, f"--- Стандартный магический квадрат (4x4) ---\n")
    output_text.insert(tk.END, f"Используется стандартный магический квадрат:\n")
    output_text.insert(tk.END, f" 16  3  2 13\n")
    output_text.insert(tk.END, f"  5 10 11  8\n")
    output_text.insert(tk.END, f"  9  6  7 12\n")
    output_text.insert(tk.END, f"  4 15 14  1\n")
    output_text.insert(tk.END, f"Сумма строк/столбцов/диагоналей: 34\n")
    output_text.insert(tk.END, f"Порядок заполнения (по убыванию значения): {indices}\n\n")


# --- Создание графического интерфейса ---
# Создаем главное окно приложения
root = tk.Tk()
# Устанавливаем заголовок окна
root.title("Шифр магического квадрата (4x4) (Модифицированный)")
# Устанавливаем начальный размер окна
root.geometry("900x700")

# --- Виджеты ---

# Фрейм для ввода текста
input_frame = ttk.Frame(root)
input_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew", columnspan=2)
root.grid_columnconfigure(0, weight=1)  # Делаем колонку 0 растягиваемой

# Метка для поля ввода фамилии и имени
input_label = ttk.Label(input_frame, text="Введите текст (фамилию и имя для остальных шифров):")
input_label.grid(row=0, column=0, sticky="w")

# Поле ввода для фамилии и имени
input_text = ttk.Entry(input_frame, width=60)
input_text.grid(row=1, column=0, sticky="ew", padx=(0, 10))
input_frame.grid_columnconfigure(0, weight=1)  # Делаем колонку 0 внутри фрейма растягиваемой
input_text.insert(0, "Колосов Станислав")

# Кнопка генерации квадрата
generate_key_button = ttk.Button(root, text="Сгенерировать квадрат", command=generate_key_action)
generate_key_button.grid(row=1, column=0, padx=10, pady=5, sticky="w")

# Кнопки для шифрования и дешифрования
button_frame = ttk.Frame(root)
button_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew", columnspan=2)

encrypt_button = ttk.Button(button_frame, text="Зашифровать", command=encrypt_action)
encrypt_button.grid(row=0, column=0, padx=(0, 5))

decrypt_button = ttk.Button(button_frame, text="Дешифровать", command=decrypt_action)
decrypt_button.grid(row=0, column=1, padx=(5, 0))

# Метка для поля вывода результата
output_label = ttk.Label(root, text="Результат:")
output_label.grid(row=3, column=0, padx=10, pady=5, sticky="w")

# Текстовое поле с прокруткой для вывода результата
output_text = scrolledtext.ScrolledText(root, width=100, height=35)
output_text.grid(row=4, column=0, padx=10, pady=5, sticky="nsew", columnspan=2)

# --- Настройка сетки ---
# Делаем так, чтобы строка 4 (где поле вывода) растягивалась при изменении размера окна
root.grid_rowconfigure(4, weight=1)

# Запуск главного цикла обработки событий tkinter
root.mainloop()
