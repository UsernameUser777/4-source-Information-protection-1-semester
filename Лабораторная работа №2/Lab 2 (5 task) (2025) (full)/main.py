import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox

def grille_cipher_encrypt(text, size=4):
    """
    Шифрует текст с помощью шифра поворотной решетки (4x4).

    Этот метод шифрования работает следующим образом:
    1.  Создается специальная решетка (трафарет) размером size x size (в данном случае 4x4).
        В решетке вырезаются определенные ячейки. Количество вырезов обычно составляет
        1/4 от общего числа ячеек (для 4x4 это 4 выреза), чтобы при 4 поворотах
        решетки (0°, 90°, 180°, 270°) все ячейки таблицы были использованы ровно один раз.
    2.  Решетка накладывается на пустую таблицу того же размера.
    3.  Исходный текст вписывается в ячейки таблицы, соответствующие вырезам в решетке,
        в определенном порядке (например, слева направо, сверху вниз).
    4.  Затем решетка поворачивается (обычно на 90 градусов по часовой стрелке), и следующие
        символы текста вписываются в *новые* ячейки, которые теперь совпадают с вырезами.
    5.  Процедура повторяется еще дважды (итого 4 раза), пока не будут заполнены все ячейки
        таблицы (или текст не закончится, тогда заполняется пробелами).
    6.  Зашифрованный текст формируется путем считывания заполненной таблицы
        (например, по строкам).

    :param text: Исходный текст для шифрования (str).
                 Пример: "Колосов Станислав".
    :param size: Размер решетки (int), должен быть 4 для данной реализации.
                 Пример: 4.
    :return: tuple:
             - encrypted_text (str): Зашифрованный текст.
             - table (list of lists): Виртуальная таблица после заполнения через решетку.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер решетки фиксирован на 4x4.")

    # Дополняем текст пробелами до длины 16 (размер таблицы 4x4)
    padded_text = text.ljust(size * size)

    # --- Определяем позиции вырезов в начальной ориентации решетки ---
    # Ключом является сама решетка, т.е. набор позиций вырезов.
    # Жестко задаем пример решетки, удовлетворяющей условию уникального покрытия.
    # Позиции вырезов в исходной ориентации (индексы строк и столбцов от 0 до 3)
    # Например, [(0, 0), (0, 2), (1, 1), (2, 0)] - это просто пример.
    # Для корректной решетки, при 4 поворотах на 90 градусов,
    # все 16 ячеек (0,0) .. (3,3) должны быть покрыты ровно один раз.
    # Проверим это вручную для выбранного примера:
    # Поворот на 90: (r, c) -> (c, size-1-r)
    # Поворот на 180: (r, c) -> (size-1-r, size-1-c)
    # Поворот на 270: (r, c) -> (size-1-c, r)
    initial_holes = [(0, 0), (0, 2), (1, 1), (2, 0)] # Выбранный набор вырезов

    # Проверка уникальности покрытия (вручную для 4x4)
    all_positions_covered = set()
    current_holes = initial_holes[:]
    for rotation in range(4): # 4 позиции решетки (0°, 90°, 180°, 270°)
        for r_h, c_h in current_holes:
            all_positions_covered.add((r_h, c_h))
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        new_holes = []
        for r_h, c_h in current_holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        current_holes = new_holes
    # Если общее количество уникальных позиций не равно размеру таблицы, решетка некорректна
    if len(all_positions_covered) != size * size:
        raise ValueError("Выбранная решетка не покрывает все ячейки при 4 поворотах.")

    # Создаем пустую виртуальную таблицу (список списков), заполненную пустыми строками
    table = [['' for _ in range(size)] for _ in range(size)]

    # --- Заполняем таблицу через решетку ---
    # Проходим 4 раза, соответствующие 4 позициям решетки
    text_index = 0 # Индекс текущего символа в дополненном тексте
    holes = initial_holes[:] # Начинаем с исходного набора вырезов
    for rotation in range(4): # 4 позиции решетки
        # Проходим по текущим позициям вырезов и заполняем таблицу
        for r_h, c_h in holes:
            # Проверяем, не закончился ли текст (хотя он должен быть дополнен)
            if text_index < len(padded_text):
                table[r_h][c_h] = padded_text[text_index]
                text_index += 1
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        # для следующей итерации цикла
        new_holes = []
        for r_h, c_h in holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        holes = new_holes # Обновляем список вырезов для следующего "наложения" решетки

    # --- Считываем зашифрованный текст из заполненной таблицы ---
    # Обычно считывается по строкам, но может быть и по столбцам.
    encrypted_chars = []
    for r in range(size): # Проходим по строкам
        for c in range(size): # Проходим по столбцам в строке
            encrypted_chars.append(table[r][c]) # Добавляем символ

    # Возвращаем зашифрованный текст в виде строки и таблицу после заполнения
    return ''.join(encrypted_chars), table

def grille_cipher_decrypt(ciphertext, size=4):
    """
    Дешифрует текст, зашифрованный шифром поворотной решетки (4x4).

    Процесс дешифрования обратен шифрованию:
    1.  Создается пустая виртуальная таблица размером size x size.
    2.  Зашифрованный текст записывается в таблицу в фиксированном порядке
        (например, по строкам, как при считывании при шифровании).
    3.  Затем, используя ту же самую решетку (с теми же позициями вырезов)
        и ту же последовательность поворотов (0°, 90°, 180°, 270°),
        символы из таблицы извлекаются в порядке, соответствующем поворотам.
        То есть, сначала считываются символы из позиций, соответствующих
        вырезам в решетке при 0° повороте, затем при 90°, и т.д.

    :param ciphertext: Зашифрованный текст (str).
    :param size: Размер решетки (int), должен быть 4 для данной реализации.
    :return: str: Восстановленный (дешифрованный) текст.
    """
    # Проверяем, что размер фиксирован на 4x4, как требуется в задании
    if size != 4:
        raise ValueError("Для данной реализации размер решетки фиксирован на 4x4.")

    # Проверяем, совпадает ли длина зашифрованного текста с размером таблицы
    if len(ciphertext) != size * size:
        raise ValueError("Длина зашифрованного текста не соответствует размеру таблицы.")

    # --- Используем ту же решетку, что и при шифровании ---
    initial_holes = [(0, 0), (0, 2), (1, 1), (2, 0)]

    # Заполняем таблицу из зашифрованного текста (по строкам)
    table = [['' for _ in range(size)] for _ in range(size)]
    text_index = 0
    for r in range(size):
        for c in range(size):
            table[r][c] = ciphertext[text_index]
            text_index += 1

    # --- Извлекаем символы из таблицы по порядку, определяемому решеткой и поворотами ---
    decrypted_chars = []
    holes = initial_holes[:]
    for rotation in range(4): # 4 позиции решетки
        # Проходим по текущим позициям вырезов и извлекаем символы из таблицы
        for r_h, c_h in holes:
            decrypted_chars.append(table[r_h][c_h])
        # Рассчитываем новые позиции вырезов после поворота на 90 градусов
        new_holes = []
        for r_h, c_h in holes:
            new_r = c_h
            new_c = size - 1 - r_h
            new_holes.append((new_r, new_c))
        holes = new_holes

    # Восстановленный текст (включая добавленные пробелы)
    decrypted_text_with_padding = ''.join(decrypted_chars)
    # Удаляем пробелы в конце, которые были добавлены при шифровании
    return decrypted_text_with_padding.rstrip(' ')


def encrypt_action():
    """
    Обработчик кнопки 'Зашифровать' для интерфейса tkinter.

    Функция извлекает текст из поля ввода, вызывает функцию шифрования
    (размер решетки фиксирован), и выводит результат (исходный текст,
    размер решетки, позиции вырезов, повороты, таблицу, зашифрованный текст)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем текст из поля ввода фамилии и имени
    text = input_text.get()

    # Проверяем, введен ли текст
    if not text:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите фамилию и имя для шифрования.\n")
        return # Выходим из функции

    try:
        # Вызываем функцию шифрования с фиксированным размером 4
        encrypted_text, table = grille_cipher_encrypt(text, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр поворотной решетки (4x4) (Шифрование) ---\n")
        # Вставляем исходное сообщение
        output_text.insert(tk.END, f"Исходное сообщение: {text}\n")
        # Вставляем размер решетки
        output_text.insert(tk.END, f"Размер решетки: 4x4\n")
        # Вставляем позиции вырезов в начальной решетке (для визуализации ключа)
        output_text.insert(tk.END, f"Позиции вырезов в начальной решетке (0-based): [(0, 0), (0, 2), (1, 1), (2, 0)]\n")
        # Вставляем информацию о поворотах
        output_text.insert(tk.END, f"Повороты решетки: 0°, 90°, 180°, 270°\n")
        # Вставляем таблицу после заполнения через решетку
        output_text.insert(tk.END, f"Таблица (после заполнения через решетку): {table}\n")
        # Вставляем зашифрованное сообщение (по строкам)
        output_text.insert(tk.END, f"Зашифрованное сообщение (по строкам): {encrypted_text}\n\n")
    except Exception as e: # Ловим любые другие ошибки (например, некорректная решетка)
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")

def decrypt_action():
    """
    Обработчик кнопки 'Дешифровать' для интерфейса tkinter.

    Функция извлекает зашифрованный текст из поля ввода, вызывает функцию дешифрования
    (размер решетки фиксирован), и выводит результат (зашифрованный текст,
    размер решетки, позиции вырезов, восстановленное сообщение)
    в текстовое поле вывода. Обрабатывает возможные ошибки.
    """
    # Получаем зашифрованный текст из поля ввода
    ciphertext = input_text.get()

    # Проверяем, введен ли зашифрованный текст
    if not ciphertext:
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем сообщение об ошибке
        output_text.insert(tk.END, "Ошибка: Введите зашифрованное сообщение для дешифрования.\n")
        return # Выходим из функции

    try:
        # Вызываем функцию дешифрования с фиксированным размером 4
        decrypted_text = grille_cipher_decrypt(ciphertext, size=4)
        # Очищаем поле вывода
        output_text.delete(1.0, tk.END)
        # Вставляем заголовок
        output_text.insert(tk.END, f"--- Шифр поворотной решетки (4x4) (Дешифрование) ---\n")
        # Вставляем зашифрованное сообщение
        output_text.insert(tk.END, f"Зашифрованное сообщение: {ciphertext}\n")
        # Вставляем размер решетки
        output_text.insert(tk.END, f"Размер решетки: 4x4\n")
        # Вставляем позиции вырезов в начальной решетке (для визуализации ключа)
        output_text.insert(tk.END, f"Позиции вырезов в начальной решетке (ключ): [(0, 0), (0, 2), (1, 1), (2, 0)]\n")
        # Вставляем восстановленное сообщение
        output_text.insert(tk.END, f"Восстановленное сообщение: {decrypted_text}\n\n")
    except Exception as e: # Ловим любые другие ошибки
        output_text.delete(1.0, tk.END)
        output_text.insert(tk.END, f"Ошибка: {e}\n")


# --- Создание графического интерфейса ---
# Создаем главное окно приложения
root = tk.Tk()
# Устанавливаем заголовок окна
root.title("Шифр поворотной решетки (4x4)")
# Устанавливаем начальный размер окна
root.geometry("900x700")

# --- Виджеты ---

# Метка для поля ввода фамилии и имени
input_label = ttk.Label(root, text="Введите текст (фамилию и имя для остальных шифров):")
# Размещаем метку в сетке окна (строка 0, столбец 0)
input_label.grid(row=0, column=0, padx=10, pady=5, sticky="w")

# Поле ввода для фамилии и имени
input_text = ttk.Entry(root, width=60)
# Размещаем поле ввода (строка 1, столбец 0, растягиваем на 2 столбца)
input_text.grid(row=1, column=0, padx=10, pady=5, sticky="ew", columnspan=2)
# Вставляем значение по умолчанию в поле ввода
input_text.insert(0, "Колосов Станислав")

# Кнопки для шифрования и дешифрования
# Размещаем кнопки под полем ввода, в отдельной строке
encrypt_button = ttk.Button(root, text="Зашифровать", command=encrypt_action)
encrypt_button.grid(row=2, column=0, padx=5, pady=10, sticky="e")

decrypt_button = ttk.Button(root, text="Дешифровать", command=decrypt_action)
decrypt_button.grid(row=2, column=1, padx=5, pady=10, sticky="w")

# Метка для поля вывода результата
output_label = ttk.Label(root, text="Результат:")
# Размещаем метку (строка 3, столбец 0)
output_label.grid(row=3, column=0, padx=10, pady=5, sticky="w")

# Текстовое поле с прокруткой для вывода результата
output_text = scrolledtext.ScrolledText(root, width=100, height=35)
# Размещаем поле вывода (строка 4, столбец 0, растягиваем на 2 столбца)
output_text.grid(row=4, column=0, padx=10, pady=5, sticky="nsew", columnspan=2)

# --- Настройка сетки ---
# Делаем так, чтобы строка 4 (где поле вывода) растягивалась при изменении размера окна
root.grid_rowconfigure(4, weight=1)
# Делаем так, чтобы столбец 0 (где основные элементы) растягивался
root.grid_columnconfigure(0, weight=1)

# Запуск главного цикла обработки событий tkinter
root.mainloop()
